//! This module implements DocBook XML output for a struct
//! representing a single entry in th emanual.

use std::io::Write;
use xml::writer::{EventWriter, XmlEvent};
use failure::Error;

/// Represent a function argument, which is either a flat identifier
/// or a pattern set.
#[derive(Debug)]
pub enum Argument {
    /// Flat function argument (e.g. `n: n * 2`).
    Flat(String),

    /// Pattern function argument (e.g. `{ name, age }: ...`)
    Pattern(Vec<String>),
}

/// Represents a single manual section describing a library function.
#[derive(Debug)]
pub struct ManualEntry {
    /// Name of the function category (e.g. 'strings', 'trivial', 'attrsets')
    pub category: String,

    /// Name of the section (used as the title)
    pub name: String,

    /// Type signature (if provided). This is not actually a checked
    /// type signature in any way.
    pub fn_type: Option<String>,

    /// Primary description of the entry. Each entry is written as a
    /// separate paragraph.
    pub description: Vec<String>,

    /// Usage example for the entry.
    pub example: Option<String>,

    /// Arguments of the function
    pub args: Vec<Argument>,
}

impl ManualEntry {
    /// Write a single DocBook entry for a documented Nix function.
    pub fn write_section_xml<W: Write>(&self, w: &mut EventWriter<W>) -> Result<(), Error> {
        let ident = format!("lib.{}.{}", self.category, self.name);

        // <section ...
        w.write(XmlEvent::start_element("section")
                .attr("xml:id", format!("function-library-{}", ident).as_str()))?;

        // <title> ...
        w.write(XmlEvent::start_element("title"))?;
        w.write(XmlEvent::start_element("function"))?;
        w.write(XmlEvent::characters(ident.as_str()))?;
        w.write(XmlEvent::end_element())?;
        w.write(XmlEvent::end_element())?;

        // <subtitle> (type signature)
        if let Some(t) = &self.fn_type {
            w.write(XmlEvent::start_element("subtitle"))?;
            w.write(XmlEvent::start_element("literal"))?;
            w.write(XmlEvent::characters(t))?;
            w.write(XmlEvent::end_element())?;
            w.write(XmlEvent::end_element())?;
        }

        // Include link to function location (location information is
        // generated by a separate script in nixpkgs)
        w.write(XmlEvent::start_element("xi:include")
                .attr("href", "./locations.xml")
                .attr("xpointer", &ident))?;
        w.write(XmlEvent::end_element())?;

        // Primary doc string
        // TODO: Split paragraphs?
        for paragraph in &self.description {
            w.write(XmlEvent::start_element("para"))?;
            w.write(XmlEvent::characters(paragraph))?;
            w.write(XmlEvent::end_element())?;
        }

        // Function argument names
        if !self.args.is_empty() {
            w.write(XmlEvent::start_element("variablelist"))?;
            for arg in &self.args {
                match arg {
                    Argument::Flat(name) => {
                        w.write(XmlEvent::start_element("varlistentry"))?;

                        w.write(XmlEvent::start_element("term"))?;
                        w.write(XmlEvent::start_element("varname"))?;
                        w.write(XmlEvent::characters(name))?;
                        w.write(XmlEvent::end_element())?;
                        w.write(XmlEvent::end_element())?;

                        w.write(XmlEvent::start_element("listitem"))?;
                        w.write(XmlEvent::start_element("para"))?;
                        w.write(XmlEvent::characters("Function argument"))?;
                        w.write(XmlEvent::end_element())?;
                        w.write(XmlEvent::end_element())?;

                        w.write(XmlEvent::end_element())?;
                    },
                    Argument::Pattern(pattern_args) => {
                        panic!("Pattern arguments: {:?}", pattern_args);
                    },
                }
            }

            w.write(XmlEvent::end_element())?;
        }

        // Example program listing (if applicable)
        //
        // TODO: In grhmc's version there are multiple (named)
        // examples, how can this be achieved automatically?
        if let Some(example) = &self.example {
            w.write(XmlEvent::start_element("example"))?;

            w.write(XmlEvent::start_element("title"))?;

            w.write(XmlEvent::start_element("function"))?;
            w.write(XmlEvent::characters(ident.as_str()))?;
            w.write(XmlEvent::end_element())?;

            w.write(XmlEvent::characters(" usage example"))?;
            w.write(XmlEvent::end_element())?;

            w.write(XmlEvent::start_element("programlisting"))?;
            w.write(XmlEvent::cdata(example))?;
            w.write(XmlEvent::end_element())?;

            w.write(XmlEvent::end_element())?;
        }

        // </section>
        w.write(XmlEvent::end_element())?;

        Ok(())
    }
}
